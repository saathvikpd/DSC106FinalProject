I am building a huffman coding visualization in svelte where the user can interact with it step by step. Here are the steps that are controlled by a button in the HuffmanController component:
1. The item with the least value is highlighted in the priority queue bar chart. (*note)
2. A node is created in the left subarea on the right side of the page from that item and it is popped from the priority queue
3. The next item with the now least value is highlighted in the queue (*note)
4. Another node is created in the right subarea on the right side of the page from that item and it is popped from the queue
5. A new internal parent node is constructed from the two child nodes on the right side of the page and two edges are drawn connecting the parent node to its children, forming a subtree.
6. The value of the new parent node is inserted into the priority queue on the left side.
7. The subtree that was just drawn is moved down to the waiting room for later use.
8. Repeat until the priority queue is empty
*note: if the item chosen from the priority queue is an internal node value, rather than constructing a new node on the right side of the page, we move the subtree from the waiting room back up to the tree-building area.

So far the HuffmanController component looks like this:
```
<script>
    import { priorityQueueStore, highlightTopBar, highlightSecondBar } from '$lib/stores.js';
    import TreeGraph from './TreeGraph.svelte';
  
    let count = 0;
    let nodeA = null;
    let nodeB = null;

    function executeNextStep() {
        let currentStep = count % 5 + 1;

        // if priorityQueueStore is empty, then we are done


        switch (currentStep) {
        case 1:
            console.log("Highlighting the top bar");
            // need to check if this is a leaf or internal (could be handled by a different function)
            highlightTopBar.set(true);
            nodeA = priorityQueueStore.peek();
            // draw nodeA on tree
            break;
        case 2:
            console.log("Highlighting the second bar");
            // remove nodeA from the priority queue
            priorityQueueStore.extractMin();
            highlightTopBar.set(false);
            highlightSecondBar.set(true);
            nodeB = priorityQueueStore.peek2();
            // draw nodeB on tree
            break;

        // in case 3 we create a new parent node from A and B and draw it on tree
        case 3:
            // remove node B from the priority queue
            priorityQueueStore.extractMin();
            highlightSecondBar.set(false);
            // create a new parent node from A and B and draw it on tree
            break;
        case 4:
            // move the new parent node to the waiting room
            break;

        default:
            console.log('Step not implemented or resetting.');
            currentStep = 0; // Reset or handle completion
            break;
        }
    
        // Prepare for the next step on the next button press
        count++;
    }
</script>
  
<button class="btn btn-primary" on:click={executeNextStep}>Next Step</button>
  
<TreeGraph leftNode={nodeA} rightNode={nodeB} />
```

I also have another component called Frequencies.svelte that is used to display the frequencies of the characters in the input string and turns them into a priority queue to be used by the encoding functions.
```
<!-- Frequencies.svelte -->
<script>
    import { createEventDispatcher } from 'svelte';
    import * as d3 from 'd3';
    import { priorityQueueStore, highlightTopBar } from '$lib/stores.js';
    import { TreeNode } from '$lib/modules/TreeNode.js';
  
    export let userInput;
    const dispatch = createEventDispatcher();
    let isSorted = false;
    let data = calculateFrequencies(userInput);

    // Function to calculate and return character frequencies in order of appearance
    function calculateFrequencies(text) {
        let sanitizedText = text.toUpperCase().replace(/[\W_]+/g, '');
        let freqMap = new Map();
        sanitizedText.split('').forEach(char => {
            freqMap.set(char, (freqMap.get(char) || 0) + 1);
        });
        return Array.from(freqMap.entries()).map(([character, frequency]) => ({ character, frequency }));
    }

    // Populate the priority queue with TreeNode objects
    function populatePriorityQueue() {
        console.log("Populating priority queue with frequency data...");
        data.forEach(({ character, frequency }) => {
            const node = new TreeNode(character, frequency);
            priorityQueueStore.insert(node);
            console.log(`Inserted ${character}: ${frequency}`);
        });
        console.log("Priority queue populated.");
    }

    // Function to sort frequencies in descending order
    function sortAndPopulateQueue() {
        dispatch('lockInput', true); // Dispatch event to lock the input box
        data.sort((a, b) => a.frequency - b.frequency);
        isSorted = true;
        populatePriorityQueue();
        updateHistogram();
    }

    // React to changes in the priority queue and update the histogram accordingly
    $: priorityQueueStore.subscribe(queue => {
        const newData = queue.map(node => ({ character: node.character, frequency: node.frequency }));
        if (JSON.stringify(newData) !== JSON.stringify(data)) {
            data = newData;
            updateHistogram();
        }
        console.log("Priority queue updated.");
    });
    
    // React to userInput changes
    $: if (userInput && !isSorted) {
        data = calculateFrequencies(userInput);
        updateHistogram();
    }

    $: $highlightTopBar, updateHistogram();

    function updateHistogram() {
        if (data.length === 0) return;
        
        const svg = d3.select('#frequency-chart');
        const margin = { top: 20, right: 30, bottom: 40, left: 40 };
        const fixedBarWidth = 20;
        const chartWidth = 400; // Fixed chart width
        const heightPerBar = 25; // Including space between bars
        const chartHeight = data.length * heightPerBar + margin.top + margin.bottom; // Dynamic chart height
        
        // Set animation duration
        const duration = 750;

        svg.attr('height', chartHeight); // Update SVG height dynamically based on data
        
        const x = d3.scaleLinear()
        .range([0, chartWidth - margin.left - margin.right])
        .domain([0, d3.max(data, d => d.frequency)]);

        const y = d3.scaleBand()
            .range([0, data.length * heightPerBar])
            .padding(0.1)
            .domain(data.map(d => d.character));

        // Only append the <g> element if it doesn't exist
        if (!svg.select('g').node()) {
            svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
        }
        const chartBody = svg.select('g');

        // Bind data to bars and labels

        const labels = chartBody.selectAll('.label').data(data, d => d.character);

        // Transition for animations
        const transition = d3.transition().duration(duration);

        // Select and bind data to a group container for each data point
        const barGroups = chartBody.selectAll(".bar-group")
            .data(data, d => d.character);

        // Enter selection for the group
        const barGroupEnter = barGroups.enter().append("g")
            .attr("class", "bar-group");

        // Append rect for each bar in the enter selection
        barGroupEnter.append("rect")
            .attr("class", "bar")
            .attr("x", 0)
            .attr("y", d => y(d.character))
            .attr("height", y.bandwidth())
            .attr("fill", "steelblue")
            .attr("rx", 5) // Rounded corners
            .attr("ry", 5)
            .attr("width", 0) // Start with a width of 0 for new bars
            .transition(d3.transition().duration(750))
            .attr("width", d => x(d.frequency)); // Transition to the correct width

        // Append text for the frequency label in the enter selection, initially hidden
        barGroupEnter.append("text")
            .attr("class", "freq-label")
            .attr("text-anchor", "start")
            .attr("dy", "0.35em")
            .style("opacity", 0) // Start with labels hidden
            .attr("x", d => x(d.frequency) + 10) // Position slightly to the right of the bar
            .attr("y", d => y(d.character) + y.bandwidth() / 2);

        // Merge the enter and update selections for bars to re-apply event listeners
        const mergedBars = barGroupEnter.merge(barGroups).select(".bar");

        mergedBars
            .on("mouseover", function(event, d) {
                d3.select(this).attr('fill', 'orange'); // Highlight color on hover
                d3.select(this.parentNode).select(".freq-label")
                    .style("opacity", 1); // Show the label on hover
            })
            .on("mouseout", function(d) {
                d3.select(this).attr('fill', 'steelblue'); // Reset color on mouse out
                d3.select(this.parentNode).select(".freq-label")
                    .style("opacity", 0); // Hide the label on mouse out
            });

        // Apply transitions to merged bars for consistent updates
        mergedBars.transition(d3.transition().duration(750))
            .attr("y", d => y(d.character))
            .attr("width", d => x(d.frequency));

        // Ensure labels for all bars, including new ones, are correctly positioned
        const mergedLabels = barGroupEnter.merge(barGroups).select(".freq-label");

        mergedLabels
            .attr("x", d => x(d.frequency) + 10) // Ensure label positions are updated
            .attr("y", d => y(d.character) + y.bandwidth() / 2)
            .text(d => d.frequency); // Update label text

        // Continue with the removal of exiting groups if needed
        barGroups.exit().remove();


        // Update labels
        labels.join(
            enter => enter.append('text')
                .attr('class', 'label')
                .attr('x', -20)
                .attr('y', d => y(d.character) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .text(d => d.character),
            update => update
                .call(update => update.transition(transition)
                .attr('y', d => y(d.character) + y.bandwidth() / 2)
                .text(d => d.character)), // Animate label changes
            exit => exit.remove()
        );

        // Additional logic to highlight the top bar if shouldHighlightTopBar is true
        if ($highlightTopBar) {
            svg.selectAll('.bar')
                .each(function(d, i) {
                if (i === 0) { // Assuming the data is already sorted, highlight the first bar
                    d3.select(this).style('fill', 'red');
                }
                });
        }
    }

    // Listen for the highlight event
    // function handleHighlight(event) {
    //     highlightedCharacter = event.detail.character;
    //     updateHistogram(highlightedCharacter=highlightedCharacter);
    // }

</script>

<button type="button" class="btn btn-primary btn-sm" on:click={sortAndPopulateQueue} disabled={isSorted}>Sort Frequencies</button>

<svg id="frequency-chart" width="400"></svg>
```

The main page is +page.svelte which looks like this:
```
<script>
    import { tweened } from 'svelte/motion';
	import { cubicInOut } from 'svelte/easing';
    import Frequencies from '$lib/components/Frequencies.svelte';
    import HuffmanController from '$lib/components/HuffmanController.svelte';
    
    let userInput = '';
    let inputLocked = false;


    // Position for animating the column. Starting from 100% (centered),
    // we'll animate this to 33% to move to the left side.
    const position = tweened(33, {
        duration: 750,
        delay: 1000,
        easing: cubicInOut
    });

    // Handle the lockInput event from Frequencies component
    function handleInputLock(event) {
        inputLocked = event.detail;
        if (inputLocked) {
            position.set(0); // Animate to move to the left
        }
    }

    function reset() {
        window.location.reload();
    }
</script>


<div class="container-fluid">

    <div class="row mb-3 align-items-start">
        <div class="col-md-4">
            <button type="button" class="btn btn-outline-danger btn-sm float-start" on:click={reset}>Reset</button>
        </div>
        <div class="col-md-4">
            <h1 class="text-center">Huffman Coding Visualization</h1>
        </div>
        <div class="col-md-4">
            <a href="/test/priorityqueue/">PriorityQueueTest</a>
            <HuffmanController />
        </div>
    </div>

    <div class="row justify-content-center" style="transform: translateX({$position}%)">
        <div class="col-md-4">
            <div class="d-flex flex-column align-items-center">
                <textarea 
                    class="text-input form-control mb-3" 
                    bind:value={userInput} 
                    placeholder="Type some text here..." 
                    disabled={inputLocked}
                ></textarea>
                <Frequencies {userInput} on:lockInput={handleInputLock}/>
            </div>
        </div>
        <div class="col-md-8">
            <p class="text-center">Tree Here</p>
        </div>
    </div>

</div>

  
<style>
/* excluded for brevity */
</style>
```

There are several helper js modules as well such as Stores.js which uses svelte stores to reactively keep track of data that needs to be shared between components.
```
// stores.js
import { writable } from 'svelte/store';

function createPriorityQueue() {
    const { subscribe, set, update } = writable([]);

    function insert(item) {
        update(items => {
            // Find the correct position for the new item
            const index = items.findIndex(el => item.frequency < el.frequency);
            const updatedItems = [...items];
            if (index !== -1) {
                updatedItems.splice(index, 0, item);
            } else {
                updatedItems.push(item);
            }
            return updatedItems;
        });
    }

    function extractMin() {
        let extractedItem = null;
        update(items => {
            if (items.length === 0) {
                throw new Error("PriorityQueue is empty");
            }
            extractedItem = items.shift();
            return items;
        });
        return extractedItem;
    }

    function peek() {
        let firstItem = null;
        update(items => {
            firstItem = items.length > 0 ? items[0] : null;
            return items; // We don't actually modify the items here
        });
        return firstItem;
    }

    function clear() {
        set([]);
    }

    return {
        subscribe,
        insert,
        extractMin,
        peek,
        clear
    };
}

export const priorityQueueStore = createPriorityQueue();

export const highlightTopBar = writable(false);
export const highlightSecondBar = writable(false);
```

And another module to define the treenode class:
```
export class TreeNode {
    constructor(character, frequency, left = null, right = null) {
        this.character = character;
        this.frequency = frequency;
        this.left = left;
        this.right = right;
        this.isLeaf = !(left || right); // true for leaf, false for internal node
    }
}
```



Lets create a new component called TreeGraph.svelte which will be responsible for drawing and animating each step of the huffman tree building process. It will be used as a child component within huffmanController and should take two TreeNodes as props, one each for the left and right children. We will use d3 to reactively draw these child nodes in the correct places. The TreeGraph component should also export a function that when called by the controller initiates animated the construction of a new parent node. You should use d3 tree layout for this purpose and make sure the tree is displayed vertically. Additionally, we need to pay attention to the two store values in '$lib/stores.js':
export const highlightTopBar = writable(false);
export const highlightSecondBar = writable(false);

If topBar is true, we want the left node to be highlighted in red, otherwise regular blue. The same goes for the right node and highlightSecondBar. 
Please show me the complete code for TreeGraph.svelte